#plot.scalescape
#' Plotting scalescape objects
#'
#' \code{plot} method for classes \code{scalescape} and \code{scalescape.boot}. For objects of
#' class \code{scalescape}, \code{summary.scalescape} returns two plots:
#' \enumerate{
#'   \item the log-likelihood values for the range parameter up to the distance (in meters),
#'    specified as the \code{max.radius} in \code{landscape_matrix}.
#'    \item the shape of the weighting function, i.e.how the weight of  the landscape predictor
#'    decreases with distance (in meters), given the maximum likelihood range value.
#'  }
#' For objects of class \code{scalescape.boot}, \code{summary.scalescape} returns two histograms:
#' \enumerate{
#'   \item the frequency with which different range parameter values were identified as optimal
#'   \item the distribution of deviance values generated by the bootstraps, from which the p-value is derived
#' }
#'
#' @param object an object of class \code{scalescape} or \code{scalescape.boot}

plot.scalescape <- function(object, ...) {
  if(!is.element("scalescape.boot", class(object))) {
    sol <- weighting_funct(object$opt.range, mod0=object$mod0, landscape.formula = object$landscape.formula,
                           data = object$data, max.Dist = object$max.Dist, landscape.vars=object$landscape.vars, weight.fn = object$weight.fn, return.coef = T)
    par(mfrow=c(length(object$opt.range),2), mai=c(1,1,.3,.3))
    for(i.range in 1:length(object$opt.range)){
      w <- data.frame(range=object$max.Dist[i.range] * .005*(1:199), logLik = NA, b = NA)
      for(i in 1:199) {
        opt.par <- object$opt.range
        opt.par[i.range] <- .005*i
        z <- weighting_funct(par=opt.par, mod0=object$mod0, landscape.formula = object$landscape.formula,
                             data = object$data, max.Dist = object$max.Dist, landscape.vars=object$landscape.vars, weight.fn = object$weight.fn, return.coef = T)
        if(length(z)>1){
          w$logLik[i] <- z$logLik
          w$b[i] <- z$coef[3]
        }
      }

      #1
      plot(logLik ~ range, data=w, typ="l", xlab="Distance", ylab="logLik")
      points(object$opt.range[i.range], object$logLik[i.range], col="red")
      mtext(side=3, paste0("Range for ",names(object$opt.range)," = ",round(object$opt.range[i.range], digits=3)))

      #2
      # Gaussian weightings
      if(object$weight.fn=="Gaussian") curve(exp(-0.5*(x/(object$opt.range[i.range]))^2),
                                        from = 0, to = object$max.Dist[i.range], ylim=c(0,1), xlab="Distance", ylab="Weighting")
      abline(v=object$opt.range[i.range], col="red", lty=2)

      # exponential weightings
      if(object$weight.fn=="exponential") curve(exp(-x/(object$opt.range[i.range])),
                                           from = 0, to = object$max.Dist[i.range], ylim=c(0,1), xlab="Distance", ylab="Weighting")
      abline(v=object$opt.range[i.range], col="red", lty=2)
    }
  }else{
      par(mfcol=c(1,1 + length(mod.full$opt.range)), mai=c(1,1,.3,.3))

      #1
      if(length(object$mod.full$opt.range) == 1){
        hist(object$mod.full$max.Dist * object$logLik.values$opt.range.boot,
             xlab="Range", main=paste0("Bootstrap for ", names(object$mod.full$opt.range)))
      }else{
        for(i.range in 1:length(object$mod.full$opt.range))
          hist(object$mod.full$max.Dist[i.range] * object$logLik.values[,paste0("opt.range.boot.",i.range)],
               xlab="Range", main=paste0("Bootstrap for ", names(object$mod.full$opt.range)[i.range]))
      }

      #2
      hist(object$logLik.values$dev, xlab="Deviance", main=paste0("Bootstrap P = ", round(object$P, digits=4)),
           xlim=c(-.01,max(c(object$logLik.values$dev,dev))))
      lines(c(dev,dev), c(0,nrow(object$logLik.values)), col="red")
    }
  }


